from typing import List
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from sqlalchemy import and_, func
from datetime import date

from app.database import get_db
from app.models import Student, Exam, ExamRegistration, Results, Notifications
from app.schemas import StudentDashboard, ExamRegistrationCreate, ResultResponse, NotificationResponse, ExamResponse, ExamRegistrationResponse
from app.core.auth import get_student

router = APIRouter()

# FR12: Can log in using credentials auto-generated by institution
# (This is handled in the auth router)

# FR13: Can register for upcoming public exams
@router.post("/register-exam", response_model=dict)
async def register_for_public_exam(
    registration_data: ExamRegistrationCreate,
    current_user: Student = Depends(get_student),
    db: Session = Depends(get_db)
):
    """FR13: Register for upcoming public exams."""
    
    # Verify exam exists and is public
    exam = db.query(Exam).filter(Exam.exam_id == registration_data.exam_id).first()
    if not exam:
        raise HTTPException(status_code=404, detail="Exam not found")
    
    # Check if registration is still open
    today = date.today()
    if exam.date and exam.date <= today:
        raise HTTPException(
            status_code=400, 
            detail="Registration period has ended"
        )
    
    # Check if already registered
    existing = db.query(ExamRegistration).filter(
        and_(
            ExamRegistration.student_id == current_user.student_id,
            ExamRegistration.exam_id == registration_data.exam_id
        )
    ).first()
    
    if existing:
        raise HTTPException(status_code=400, detail="Already registered for this exam")
    
    # Create registration
    registration = ExamRegistration(
        student_id=current_user.student_id,
        exam_id=registration_data.exam_id,
        status="Pending"
    )
    
    db.add(registration)
    db.commit()
    db.refresh(registration)
    
    return {
        "success": True,
        "message": f"Successfully registered for {exam.title}",
        "registration_id": str(registration.registration_id)
    }

# FR14: Can view their results from their dashboard
@router.get("/results", response_model=List[dict])
async def view_my_results(
    current_user: Student = Depends(get_student),
    db: Session = Depends(get_db)
):
    """FR14: View student's own results from dashboard."""
    
    results = db.query(Results).join(Exam).filter(
        and_(
            Results.student_id == current_user.student_id,
            Results.is_published == True
        )
    ).all()
    
    formatted_results = []
    for result in results:
        exam = result.exam
        formatted_result = {
            "result_id": str(result.result_id),
            "exam_title": exam.title,
            "exam_type": exam.type,
            "exam_level": exam.level,
            "exam_date": exam.date.isoformat() if exam.date else None,
            "scores": result.scores if result.scores else {},
            "grade": result.grade,
            "status": result.status,
            "published_date": result.published_date.isoformat() if result.published_date else None,
            "remarks": result.remarks
        }
        formatted_results.append(formatted_result)
    
    return formatted_results

# FR15: Can receive notifications for new exams or results published
@router.get("/notifications", response_model=List[dict])
async def get_notifications(
    unread_only: bool = False,
    limit: int = 20,
    current_user: Student = Depends(get_student),
    db: Session = Depends(get_db)
):
    """FR15: Receive notifications for new exams or results."""
    
    query = db.query(Notifications).filter(
        Notifications.user_id == current_user.student_id
    )
    
    if unread_only:
        query = query.filter(Notifications.is_read == False)
    
    notifications = query.order_by(Notifications.created_at.desc()).limit(limit).all()
    
    formatted_notifications = []
    for notification in notifications:
        formatted_notification = {
            "notification_id": str(notification.notification_id),
            "message": notification.message,
            "date": notification.date.isoformat() if notification.date else None,
            "is_read": notification.is_read,
            "created_at": notification.created_at.isoformat() if notification.created_at else None
        }
        formatted_notifications.append(formatted_notification)
    
    return formatted_notifications

@router.post("/notifications/{notification_id}/mark-read", response_model=dict)
async def mark_notification_read(
    notification_id: str,
    current_user: Student = Depends(get_student),
    db: Session = Depends(get_db)
):
    """Mark notification as read."""
    
    notification = db.query(Notifications).filter(
        and_(
            Notifications.notification_id == notification_id,
            Notifications.user_id == current_user.student_id
        )
    ).first()
    
    if not notification:
        raise HTTPException(status_code=404, detail="Notification not found")
    
    notification.is_read = True
    notification.read_at = func.now()
    db.commit()
    
    return {"success": True, "message": "Notification marked as read"}

@router.get("/available-exams", response_model=List[dict])
async def get_available_exams(
    current_user: Student = Depends(get_student),
    db: Session = Depends(get_db)
):
    """Get exams available for registration."""
    
    today = date.today()
    
    # Get active exams that are currently open for registration
    available_exams = db.query(Exam).filter(
        Exam.status == "Active",
        Exam.date >= today  # Future exams only
    ).all()
    
    # Check which exams the student is already registered for
    registered_exam_ids = db.query(ExamRegistration.exam_id).filter(
        ExamRegistration.student_id == current_user.student_id
    ).all()
    registered_exam_ids = [str(exam_id[0]) for exam_id in registered_exam_ids]
    
    formatted_exams = []
    for exam in available_exams:
        is_registered = str(exam.exam_id) in registered_exam_ids
        
        formatted_exam = {
            "exam_id": str(exam.exam_id),
            "title": exam.title,
            "type": exam.type,
            "level": exam.level,
            "date": exam.date.isoformat() if exam.date else None,
            "description": exam.description,
            "duration": exam.duration,
            "is_registered": is_registered,
            "can_register": not is_registered and exam.date and exam.date > today
        }
        formatted_exams.append(formatted_exam)
    
    return formatted_exams

@router.get("/registrations", response_model=List[dict])
async def get_my_registrations(
    current_user: Student = Depends(get_student),
    db: Session = Depends(get_db)
):
    """Get student's exam registrations."""
    
    registrations = db.query(ExamRegistration).join(Exam).filter(
        ExamRegistration.student_id == current_user.student_id
    ).all()
    
    formatted_registrations = []
    for registration in registrations:
        exam = registration.exam
        
        formatted_registration = {
            "registration_id": str(registration.registration_id),
            "exam_id": str(registration.exam_id),
            "exam_title": exam.title,
            "exam_type": exam.type,
            "exam_date": exam.date.isoformat() if exam.date else None,
            "registration_date": registration.registration_date.isoformat() if registration.registration_date else None,
            "status": registration.status,
            "candidate_number": registration.candidate_number,
            "registration_fee": float(registration.registration_fee) if registration.registration_fee else None,
            "fee_paid": registration.fee_paid,
            "payment_date": registration.payment_date.isoformat() if registration.payment_date else None
        }
        formatted_registrations.append(formatted_registration)
    
    return formatted_registrations

# Complete dashboard view
@router.get("/dashboard", response_model=dict)
async def get_student_dashboard(
    current_user: Student = Depends(get_student),
    db: Session = Depends(get_db)
):
    """Get complete student dashboard with all relevant information."""
    
    # Student basic info
    student_info = {
        "student_id": str(current_user.student_id),
        "first_name": current_user.first_name,
        "last_name": current_user.last_name,
        "email": current_user.email,
        "phone_number": current_user.phone_number,
        "gender": current_user.gender,
        "institution_name": current_user.institution_name,
        "is_active": current_user.is_active,
        "created_at": current_user.created_at.isoformat() if current_user.created_at else None
    }
    
    # Available exams (public, active, future)
    today = date.today()
    available_exams = db.query(Exam).filter(
        Exam.status == "Active",
        Exam.date >= today
    ).limit(5).all()
    
    # Student's registrations
    registrations = db.query(ExamRegistration).join(Exam).filter(
        ExamRegistration.student_id == current_user.student_id
    ).limit(10).all()
    
    # Published results
    results = db.query(Results).join(Exam).filter(
        and_(
            Results.student_id == current_user.student_id,
            Results.is_published == True
        )
    ).limit(5).all()
    
    # Recent notifications (unread first)
    notifications = db.query(Notifications).filter(
        Notifications.user_id == current_user.student_id
    ).order_by(Notifications.is_read.asc(), Notifications.created_at.desc()).limit(5).all()
    
    # Format data for response
    formatted_available_exams = []
    for exam in available_exams:
        formatted_available_exams.append({
            "exam_id": str(exam.exam_id),
            "title": exam.title,
            "type": exam.type,
            "level": exam.level,
            "date": exam.date.isoformat() if exam.date else None,
            "description": exam.description
        })
    
    formatted_registrations = []
    for registration in registrations:
        exam = registration.exam
        formatted_registrations.append({
            "registration_id": str(registration.registration_id),
            "exam_title": exam.title,
            "exam_type": exam.type,
            "status": registration.status,
            "candidate_number": registration.candidate_number,
            "registration_date": registration.registration_date.isoformat() if registration.registration_date else None
        })
    
    formatted_results = []
    for result in results:
        exam = result.exam
        formatted_results.append({
            "result_id": str(result.result_id),
            "exam_title": exam.title,
            "exam_type": exam.type,
            "grade": result.grade,
            "status": result.status,
            "published_date": result.published_date.isoformat() if result.published_date else None
        })
    
    formatted_notifications = []
    for notification in notifications:
        formatted_notifications.append({
            "notification_id": str(notification.notification_id),
            "message": notification.message,
            "is_read": notification.is_read,
            "date": notification.date.isoformat() if notification.date else None
        })
    
    # Dashboard statistics
    total_registrations = db.query(ExamRegistration).filter(
        ExamRegistration.student_id == current_user.student_id
    ).count()
    
    total_results = db.query(Results).filter(
        and_(
            Results.student_id == current_user.student_id,
            Results.is_published == True
        )
    ).count()
    
    unread_notifications = db.query(Notifications).filter(
        and_(
            Notifications.user_id == current_user.student_id,
            Notifications.is_read == False
        )
    ).count()
    
    return {
        "student_info": student_info,
        "available_exams": formatted_available_exams,
        "registered_exams": formatted_registrations,
        "recent_results": formatted_results,
        "notifications": formatted_notifications,
        "statistics": {
            "total_registrations": total_registrations,
            "total_results": total_results,
            "unread_notifications": unread_notifications,
            "available_exams_count": len(formatted_available_exams)
        }
    }

@router.get("/profile", response_model=dict)
async def get_student_profile(
    current_user: Student = Depends(get_student),
    db: Session = Depends(get_db)
):
    """Get detailed student profile information."""
    
    return {
        "student_id": str(current_user.student_id),
        "first_name": current_user.first_name,
        "last_name": current_user.last_name,
        "email": current_user.email,
        "phone_number": current_user.phone_number,
        "gender": current_user.gender,
        "institution_name": current_user.institution_name,
        "is_active": current_user.is_active,
        "created_at": current_user.created_at.isoformat() if current_user.created_at else None,
        "updated_at": current_user.updated_at.isoformat() if current_user.updated_at else None
    }

@router.put("/profile", response_model=dict)
async def update_student_profile(
    profile_data: dict,
    current_user: Student = Depends(get_student),
    db: Session = Depends(get_db)
):
    """Update student profile information (limited fields)."""
    
    # Students can only update certain fields
    allowed_fields = ["phone_number"]
    
    for field, value in profile_data.items():
        if field in allowed_fields and hasattr(current_user, field):
            setattr(current_user, field, value)
    
    current_user.updated_at = func.now()
    db.commit()
    db.refresh(current_user)
    
    return {
        "success": True,
        "message": "Profile updated successfully",
        "updated_fields": list(profile_data.keys())
    }
